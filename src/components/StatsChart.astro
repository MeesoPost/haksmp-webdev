---
// StatsChart.astro - GitHub-style contribution calendar
interface Props {
  chartId: string;
  title: string;
  dataUrl?: string;
  description?: string;
}

const { chartId, title, dataUrl, description } = Astro.props;
---

<div class="stats-chart">
  <div class="stats-chart__header">
    <h3 class="stats-chart__title">{title}</h3>
    {description && <p class="stats-chart__description">{description}</p>}
  </div>
  <div class="stats-chart__container" id={chartId}></div>
</div>

<style>
  .stats-chart {
    background: var(--root-color--primary-dark);
    border: 4px solid var(--root-color--primary);
    border-radius: 0;
    padding: 0;
    margin: 0;
    box-shadow: 
      8px 8px 0 var(--root-color--primary-darkest),
      0 0 0 1px var(--root-color--support);
    position: relative;
    overflow: hidden;
  }

  .stats-chart::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 8px;
    background: var(--root-color--support);
  }

  .stats-chart__header {
    background: var(--root-color--primary);
    padding: var(--space-md);
    border-bottom: 3px solid var(--root-color--support);
  }

  .stats-chart__title {
    font-family: var(--root-font-family--primary);
    color: var(--root-color--grey);
    font-size: var(--root-heading-3-size);
    margin-bottom: var(--space-xs);
    text-shadow: 3px 3px 0 var(--root-color--primary-darkest);
  }

  .stats-chart__description {
    font-family: var(--root-font-family--primary);
    color: var(--root-color--grey);
    font-size: 0.875rem;
    opacity: 0.9;
    margin: 0;
  }

  .stats-chart__container {
    background: var(--root-color--primary-darkest);
    padding: var(--space-xl) var(--space-lg);
    min-height: 200px;
    position: relative;
  }

  @media (max-width: 768px) {
    .stats-chart {
      box-shadow: 
        4px 4px 0 var(--root-color--primary-darkest),
        0 0 0 1px var(--root-color--support);
    }

    .stats-chart__header {
      padding: var(--space-sm);
    }

    .stats-chart__container {
      padding: var(--space-md);
      min-height: 180px;
    }
  }
</style>

<script is:inline define:vars={{ chartId, dataUrl }}>
  function getVegaSpec(chartId, data) {
    const colors = {
      primary: '#2b5278',
      primaryLight: '#4682B4',
      secondary: '#569503',
      secondaryLight: '#7BC605',
      secondaryLighter: '#A0E830',
      support: '#E87A2F',
      supportLight: '#FF9D5C',
      grey: '#F0F0ED',
      background: '#1a3a52',
      backgroundDark: '#0f2436',
      gridBackground: '#1a2837'
    };

    // GITHUB-STYLE CONTRIBUTION CALENDAR
    if (chartId.includes('contribution')) {
      // Transform data for calendar layout
      const calendarData = data.map((d, index) => {
        const date = new Date(d.date);
        return {
          ...d,
          day: date.getDay(), // 0 = Sunday, 6 = Saturday
          week: Math.floor(index / 7),
          dateStr: d.date
        };
      });

      const maxPlaytime = Math.max(...data.map(d => d.playtime));

      return {
        $schema: 'https://vega.github.io/schema/vega-lite/v5.json',
        width: 900,
        height: 150,
        config: {
          background: colors.backgroundDark,
          view: { stroke: null }
        },
        data: { values: calendarData },
        mark: {
          type: 'rect',
          strokeWidth: 2,
          cornerRadius: 2
        },
        encoding: {
          x: {
            field: 'week',
            type: 'ordinal',
            axis: null
          },
          y: {
            field: 'day',
            type: 'ordinal',
            sort: [1, 2, 3, 4, 5, 6, 0],
            axis: {
              title: null,
              labelAngle: 0,
              labelAlign: 'right',
              labelPadding: 10,
              labelExpr: "['', 'Ma', '', 'Wo', '', 'Vr', ''][datum.value]",
              labelColor: colors.grey,
              labelFont: 'Monocraft, monospace',
              labelFontSize: 11,
              tickSize: 0,
              domain: false
            }
          },
          color: {
            field: 'playtime',
            type: 'quantitative',
            scale: {
              domain: [0, maxPlaytime * 0.25, maxPlaytime * 0.5, maxPlaytime * 0.75, maxPlaytime],
              range: [colors.gridBackground, colors.secondary, colors.secondaryLight, colors.secondaryLighter, colors.support]
            },
            legend: null
          },
          stroke: {
            condition: {
              param: 'hover',
              empty: false,
              value: colors.supportLight
            },
            value: colors.primary
          },
          strokeWidth: {
            condition: {
              param: 'hover',
              empty: false,
              value: 3
            },
            value: 2
          },
          size: {
            value: 500
          },
          tooltip: [
            { field: 'dateStr', type: 'temporal', title: 'Datum', format: '%d %B %Y' },
            { field: 'playtime', type: 'quantitative', title: 'Speeltijd', format: '.1f' },
            { field: 'players', type: 'quantitative', title: 'Actieve Spelers' }
          ]
        },
        params: [
          {
            name: 'hover',
            select: { type: 'point', on: 'mouseover', clear: 'mouseout' }
          }
        ]
      };
    }

    // ACTIVITY OVERVIEW RADAR CHART
    if (chartId.includes('overview')) {
      // Calculate totals and averages
      const totalPlaytime = data.reduce((sum, d) => sum + d.playtime, 0);
      const totalDistance = data.reduce((sum, d) => sum + d.distance, 0);
      const totalBlocksPlaced = data.reduce((sum, d) => sum + d.blocksPlaced, 0);
      const totalBlocksBroken = data.reduce((sum, d) => sum + d.blocksBroken, 0);
      const avgPlayers = data.reduce((sum, d) => sum + d.players, 0) / data.length;

      // Normalize to percentages (0-100)
      const maxPlaytime = Math.max(...data.map(d => d.playtime));
      const maxDistance = Math.max(...data.map(d => d.distance));
      const maxBlocksPlaced = Math.max(...data.map(d => d.blocksPlaced));
      const maxBlocksBroken = Math.max(...data.map(d => d.blocksBroken));
      const maxPlayers = Math.max(...data.map(d => d.players));

      const radarData = [
        { 
          category: 'Speeltijd', 
          value: (totalPlaytime / (maxPlaytime * data.length)) * 100,
          actual: totalPlaytime.toFixed(0) + ' uur'
        },
        { 
          category: 'Afstand', 
          value: (totalDistance / (maxDistance * data.length)) * 100,
          actual: (totalDistance / 1000000).toFixed(1) + 'M blocks'
        },
        { 
          category: 'Blocks Geplaatst', 
          value: (totalBlocksPlaced / (maxBlocksPlaced * data.length)) * 100,
          actual: (totalBlocksPlaced / 1000000).toFixed(1) + 'M'
        },
        { 
          category: 'Blocks Gebroken', 
          value: (totalBlocksBroken / (maxBlocksBroken * data.length)) * 100,
          actual: (totalBlocksBroken / 1000000).toFixed(1) + 'M'
        },
        { 
          category: 'Gemiddeld Spelers', 
          value: (avgPlayers / maxPlayers) * 100,
          actual: avgPlayers.toFixed(1) + ' spelers'
        }
      ];

      return {
        $schema: 'https://vega.github.io/schema/vega-lite/v5.json',
        width: 400,
        height: 400,
        config: {
          background: colors.backgroundDark,
          view: { stroke: null }
        },
        data: { values: radarData },
        layer: [
          {
            mark: { type: 'arc', innerRadius: 30, stroke: colors.support, strokeWidth: 3 },
            encoding: {
              theta: { field: 'value', type: 'quantitative', stack: true, scale: { domain: [0, 100] } },
              color: {
                field: 'category',
                type: 'nominal',
                scale: {
                  domain: radarData.map(d => d.category),
                  range: [colors.secondaryLight, colors.support, colors.primaryLight, colors.supportLight, colors.secondaryLighter]
                },
                legend: {
                  orient: 'bottom',
                  titleColor: colors.grey,
                  labelColor: colors.grey,
                  titleFont: 'Monocraft, monospace',
                  labelFont: 'Monocraft, monospace',
                  labelFontSize: 11
                }
              },
              opacity: {
                condition: {
                  param: 'hover',
                  value: 1
                },
                value: 0.85
              },
              tooltip: [
                { field: 'category', type: 'nominal', title: 'Categorie' },
                { field: 'actual', type: 'nominal', title: 'Totaal' },
                { field: 'value', type: 'quantitative', title: 'Percentage', format: '.0f' }
              ]
            }
          }
        ],
        params: [
          {
            name: 'hover',
            select: { type: 'point', on: 'mouseover', clear: 'mouseout' }
          }
        ]
      };
    }

    return null;
  }

  async function waitForVega() {
    return new Promise((resolve, reject) => {
      let attempts = 0;
      const maxAttempts = 50;
      
      const checkInterval = setInterval(() => {
        attempts++;
        if (window.vegaEmbed) {
          clearInterval(checkInterval);
          resolve();
        } else if (attempts >= maxAttempts) {
          clearInterval(checkInterval);
          reject(new Error('Vega failed to load'));
        }
      }, 100);
    });
  }

  async function initChart() {
    const container = document.getElementById(chartId);
    if (!container) {
      console.error(`Container ${chartId} not found`);
      return;
    }

    try {
      await waitForVega();

      let data;
      if (dataUrl) {
        const response = await fetch(dataUrl);
        data = await response.json();
      } else {
        console.error('No data URL provided');
        return;
      }

      const spec = getVegaSpec(chartId, data);
      
      if (spec) {
        console.log(`Rendering ${chartId}`);
        await window.vegaEmbed(`#${chartId}`, spec, {
          actions: false,
          renderer: 'svg',
          hover: true
        });
        console.log(`Successfully rendered ${chartId}`);
      } else {
        console.error(`No spec generated for ${chartId}`);
      }
    } catch (error) {
      console.error(`Error initializing chart ${chartId}:`, error);
      container.innerHTML = `
        <div style="color: var(--root-color--grey); text-align: center; padding: var(--space-lg); font-family: var(--root-font-family--primary);">
          <p style="font-size: 2rem; margin-bottom: 1rem;">âš </p>
          <p>Kon statistieken niet laden</p>
        </div>
      `;
    }
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initChart);
  } else {
    initChart();
  }
</script>