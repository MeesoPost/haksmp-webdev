<div class="tron-grid" id="tron-grid"></div>

<style>
  .tron-grid {
    position: absolute;
    inset: 0;
    pointer-events: none;
    z-index: 0;
    overflow: hidden;
  }

  .grid-line {
    position: absolute;
    opacity: 1;
    transition: opacity 0.3s ease;
  }

  /* Reduced motion support */
  @media (prefers-reduced-motion: reduce) {
    .grid-line.animate {
      animation: none !important;
      width: 100% !important;
      height: 100% !important;
      opacity: 0.3 !important;
    }
  }
</style>

<script>
  function initTronGrid() {
    const container = document.getElementById('tron-grid');
    if (!container) return;

    const gridSize = 12;
    const lineDelay = 1;
    
    container.innerHTML = '';
    
    const rect = container.getBoundingClientRect();
    const width = rect.width;
    const height = rect.height;
    
    if (width === 0 || height === 0) {
      setTimeout(initTronGrid, 100);
      return;
    }
    
    const lines = [];
    
    // Create horizontal lines
    for (let y = 0; y <= height; y += gridSize) {
      const line = document.createElement('div');
      line.className = 'grid-line horizontal';
      line.style.cssText = `position:absolute;top:${y}px;left:0;width:0;height:1px;background:rgba(255,255,255,0.06);box-shadow:0 0 0.5px rgba(255,255,255,0.1)`;
      container.appendChild(line);
      lines.push({ element: line, type: 'horizontal' });
    }
    
    // Create vertical lines
    for (let x = 0; x <= width; x += gridSize) {
      const line = document.createElement('div');
      line.className = 'grid-line vertical';
      line.style.cssText = `position:absolute;left:${x}px;top:0;width:1px;height:0;background:rgba(255,255,255,0.06);box-shadow:0 0 0.5px rgba(255,255,255,0.1)`;
      container.appendChild(line);
      lines.push({ element: line, type: 'vertical' });
    }
    
    // Shuffle lines
    for (let i = lines.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [lines[i], lines[j]] = [lines[j], lines[i]];
    }
    
    // Animate lines
    lines.forEach((line, index) => {
      const delay = index * lineDelay + (line.type === 'vertical' ? 600 : 0);
      setTimeout(() => {
        if (line.type === 'horizontal') {
          line.element.style.transition = 'width 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
          line.element.style.width = width + 'px';
        } else {
          line.element.style.transition = 'height 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
          line.element.style.height = height + 'px';
        }
      }, delay);
    });
  } 

  // Initialize - NO UNLOAD HANDLER!
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => setTimeout(initTronGrid, 800));
  } else {
    setTimeout(initTronGrid, 800);
  }

  // Reinitialize on resize
  let resizeTimeout;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(initTronGrid, 200);
  });

  // âœ… Use pagehide instead of unload for cleanup (bfcache friendly)
  window.addEventListener('pagehide', () => {
    // Cleanup if needed (doesn't block bfcache)
  });
</script>